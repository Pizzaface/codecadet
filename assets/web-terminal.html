<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'SF Mono', 'Monaco', 'Menlo', 'Consolas', 'DejaVu Sans Mono', monospace;
        }
        #terminal {
            width: 100%;
            height: 100vh;
            background-color: #000;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-unicode11@0.4.0/lib/xterm-addon-unicode11.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-webgl@0.14.0/lib/xterm-addon-webgl.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <script>
        // Create terminal instance with proper CR/LF handling
        var DEBUG = false;
        var terminal = new Terminal({
            theme: {
                background: '#000000',
                foreground: '#ffffff',
                cursor: '#ffffff',
                cursorAccent: '#000000',
                selection: '#333333',
                black: '#000000',
                red: '#cd3131',
                green: '#0dbc79',
                yellow: '#e5e510',
                blue: '#2472c8',
                magenta: '#bc3fbc',
                cyan: '#11a8cd',
                white: '#e5e5e5',
                brightBlack: '#666666',
                brightRed: '#f14c4c',
                brightGreen: '#23d18b',
                brightYellow: '#f5f543',
                brightBlue: '#3b8eea',
                brightMagenta: '#d670d6',
                brightCyan: '#29b8db',
                brightWhite: '#ffffff'
            },
            fontSize: 12,
            fontFamily: '"SF Mono", "Monaco", "Menlo", "Consolas", "DejaVu Sans Mono", monospace',
            cursorBlink: true,
            cursorStyle: 'block',
            scrollback: 10000,
            tabStopWidth: 4,
            cols: 120,
            rows: 30,
            allowTransparency: false,
            // Settings for proper animation handling
            windowsMode: false,
            macOptionIsMeta: true,
            rightClickSelectsWord: true,
            convertEol: false,  // Disable to fix animation newline issues
            scrollOnUserInput: false,  // Don't auto-scroll
            disableStdin: false,
            allowProposedApi: true,
            // Bell configuration
            bellSound: null,  // Disable default bell sound (we'll handle it in Qt)
            bellStyle: 'sound'  // Enable bell detection
        });

        // Add addons
        var fitAddon = new FitAddon.FitAddon();
        var webLinksAddon = new WebLinksAddon.WebLinksAddon();
        var unicode11Addon = new Unicode11Addon.Unicode11Addon();

        terminal.loadAddon(fitAddon);
        terminal.loadAddon(webLinksAddon);
        terminal.loadAddon(unicode11Addon);
        try {
            var webglAddon = new WebglAddon.WebglAddon();
            terminal.loadAddon(webglAddon);
            if (DEBUG) console.log('WebGL renderer enabled');
        } catch (e) {
            if (DEBUG) console.log('WebGL addon unavailable:', e);
        }
        // Ensure correct Unicode width handling
        terminal.unicode.activeVersion = '11';

        // Open terminal
        terminal.open(document.getElementById('terminal'));
        fitAddon.fit();

        // Set up Qt WebChannel communication
        var qtBridge = null;
        new QWebChannel(qt.webChannelTransport, function (channel) {
            qtBridge = channel.objects.qtBridge;
            console.log('Qt WebChannel connected');
            
            // Set up bell event handler
            terminal.onBell(function() {
                if (qtBridge && qtBridge.handle_bell_event) {
                    qtBridge.handle_bell_event();
                } else {
                    if (DEBUG) console.log('Qt bridge not ready for bell event');
                }
            });
        });

        // Handle input from terminal
        terminal.onData(function(data) {
            if (qtBridge) {
                qtBridge.write_to_pty(data);
            } else {
                if (DEBUG) console.log('Qt bridge not ready, data:', data);
            }
        });

        // Debounce helper for resize events
        var resizeTimer = null;
        var lastCols = null;
        var lastRows = null;
        var isResizing = false;

        function handleResize(force) {
            if (typeof force === 'undefined') force = false;
            if (isResizing && !force) {
                console.log('[DEBUG] Resize blocked - already resizing');
                return;
            }

            isResizing = true;
            console.log('[DEBUG] Starting resize, force:', force);
            fitAddon.fit();
            const dims = fitAddon.proposeDimensions();

            if (dims && qtBridge) {
                // Only resize PTY if dimensions actually changed
                if (dims.cols !== lastCols || dims.rows !== lastRows) {
                    console.log('[DEBUG] PTY resize:', lastCols + 'x' + lastRows + ' -> ' + dims.cols + 'x' + dims.rows);
                    lastCols = dims.cols;
                    lastRows = dims.rows;
                    qtBridge.resize_pty(dims.cols, dims.rows);
                } else {
                    console.log('[DEBUG] No PTY resize needed, dimensions unchanged');
                }
            }

            setTimeout(function() {
                isResizing = false;
                console.log('[DEBUG] Resize lock released');
            }, 100);
        }

        // Handle window resize with debouncing
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() { handleResize(true); }, 250);
        });

        // Initial fit when bridge is ready
        setTimeout(function() {
            handleResize();
        }, 500);

        // rAF-based never-drop queue for terminal writes (strings or Uint8Array)
        var pending = [];
        var scheduled = false;

        function writeItem(item) {
            if (item instanceof Uint8Array) {
                try {
                    terminal.write(item);
                } catch (e) {
                    // Fallback: decode bytes to UTF-8 string
                    if (!window.__xtermTextDecoder) {
                        try { window.__xtermTextDecoder = new TextDecoder('utf-8'); } catch (_) { window.__xtermTextDecoder = null; }
                    }
                    if (window.__xtermTextDecoder) {
                        try { terminal.write(window.__xtermTextDecoder.decode(item)); } catch (e2) { if (DEBUG) console.log('decode fallback failed', e2); }
                    }
                }
            } else {
                terminal.write(item);
            }
        }

        function flushPending() {
            scheduled = false;
            if (!pending.length) return;
            var batch = pending;
            pending = [];
            for (var i = 0; i < batch.length; i++) {
                writeItem(batch[i]);
            }
        }

        function scheduleFlush() {
            if (scheduled) return;
            scheduled = true;
            if (window.requestAnimationFrame) {
                requestAnimationFrame(flushPending);
            } else {
                setTimeout(flushPending, 16);
            }
        }

        // Global functions to write data to terminal
        window.writeToTerminal = function(data) {
            if (DEBUG && (data.indexOf('\r') !== -1 || data.indexOf('\n') !== -1)) {
                console.log('[DEBUG] writeToTerminal CR/LF len:', data.length);
            }
            pending.push(data);
            scheduleFlush();
        };

        function base64ToUint8Array(b64) {
            var binary = atob(b64);
            var len = binary.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        window.writeToTerminalBase64 = function(b64) {
            try {
                var bytes = base64ToUint8Array(b64);
                pending.push(bytes);
                scheduleFlush();
            } catch (e) {
                if (DEBUG) console.log('Base64 decode failed:', e);
            }
        };

        // Focus terminal
        terminal.focus();

        if (DEBUG) console.log('Terminal initialized');
    </script>
</body>
</html>


